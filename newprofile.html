<script>
  const loadingMessages = [
    "ðŸ§  Scanning ApeChain...",
    "ðŸŽ· Looking for music in the blockchain...",
    "ðŸ™ Checking the church...",
    "ðŸ¦ Ape monks decoding grooves...",
    "ðŸŽ¶ Tuning vinyl in hyperspace...",
    "ðŸŒ Spinning bananas into beats...",
    "ðŸ”Š Listening for lost records...",
    "ðŸ§¬ Synthesizing rare sounds..."
  ];
  let messageIndex = 0;
  const loadingText = document.getElementById("loadingText");
  const progressBarFill = document.getElementById("progressBarFill");
  let intervalId;

  function startLoadingAnimation() {
    document.getElementById("loadingIndicator").style.display = "block";
    messageIndex = 0;
    intervalId = setInterval(() => {
      loadingText.innerText = loadingMessages[messageIndex % loadingMessages.length];
      messageIndex++;
    }, 2000);
  }

  function updateProgressBar(processed, total) {
    const percent = Math.round((processed / total) * 100);
    progressBarFill.style.width = percent + "%";
  }

  function range(start, end) {
    return Array.from({ length: end - start + 1 }, (_, i) => i + start);
  }

  function resolveIPFS(uri) {
    return uri.startsWith("ipfs://") ? "https://ipfs.io/ipfs/" + uri.slice(7) : uri;
  }

  async function switchToApeChain(web3) {
    try {
      await window.ethereum.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: "0x8183" }] // 33139 in hex
      });
    } catch (err) {
      if (err.code === 4902) {
        try {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: "0x8183",
              chainName: "ApeChain",
              nativeCurrency: { name: "APE", symbol: "APE", decimals: 18 },
              rpcUrls: ["https://apechain.drpc.org"],
              blockExplorerUrls: ["https://apescan.io"]
            }]
          });
        } catch (addError) {
          alert("Failed to add ApeChain network");
        }
      } else {
        alert("Failed to switch to ApeChain");
      }
    }
  }

  async function connect() {
    if (!window.ethereum) return alert("Please install MetaMask!");

    const web3 = new Web3(window.ethereum);
    await window.ethereum.request({ method: 'eth_requestAccounts' });
    await switchToApeChain(web3);

    const accounts = await web3.eth.getAccounts();
    const userAddress = accounts[0];

    const message = "Sign this message to confirm your wallet for Mutant Records.";
    try {
      await web3.eth.personal.sign(message, userAddress);
    } catch (err) {
      alert("Signature declined. Wallet not connected.");
      return;
    }

    document.getElementById("walletAddress").innerText = "Wallet: " + userAddress;
    document.getElementById("loginSection").style.display = "none";
    document.getElementById("profileSection").style.display = "block";
    document.getElementById("loadingIndicator").style.display = "block";

    startLoadingAnimation();

    const contractA = "0xed10cd2183de930c70c812d237d5ee763a9bbc52";
    const contractB = "0xdfa50db2aa335e8ccd0671ca11abce7938a3ec09";
    const contractOG = "0xbbe59d056e8a1ce9acc0b83574075f41d0aeca07";
    const inkspireContract = "0x00d48b06b39f76e45966ff11b318059620ac470b";

    const contractABI721 = [
      { "constant": true, "inputs": [{ "name": "tokenId", "type": "uint256" }], "name": "ownerOf", "outputs": [{ "name": "owner", "type": "address" }], "type": "function" },
      { "constant": true, "inputs": [{ "name": "tokenId", "type": "uint256" }], "name": "tokenURI", "outputs": [{ "name": "uri", "type": "string" }], "type": "function" }
    ];

    const contractABI1155 = [
      { "constant": true, "inputs": [{ "name": "account", "type": "address" }, { "name": "id", "type": "uint256" }], "name": "balanceOf", "outputs": [{ "name": "", "type": "uint256" }], "type": "function" }
    ];

    const badgeGrid = document.getElementById("badgeGrid");
    const inkspireGrid = document.getElementById("inkspireGrid");
    badgeGrid.innerHTML = "";
    inkspireGrid.innerHTML = "";

    const contractAInstance = new web3.eth.Contract(contractABI721, contractA);
    const contractBInstance = new web3.eth.Contract(contractABI721, contractB);
    const contractOGInstance = new web3.eth.Contract(contractABI1155, contractOG);
    const inkspireInstance = new web3.eth.Contract(contractABI721, inkspireContract);

    let badge1 = false, badge2 = false, badge3 = false, badge5 = false;
    const seenNames = new Set();
    const badgeURIs = [], inkspireURIs = [];

    async function scanContract(contract, tokenIds, label) {
      let processed = 0;
      for (let i = 0; i < tokenIds.length; i++) {
        try {
          const owner = await contract.methods.ownerOf(tokenIds[i]).call();
          if (owner.toLowerCase() === userAddress.toLowerCase()) {
            const uri = resolveIPFS(await contract.methods.tokenURI(tokenIds[i]).call());
            const metadata = await fetch(uri).then(r => r.json());
            if (seenNames.has(metadata.name)) continue;
            seenNames.add(metadata.name);
            const image = resolveIPFS(metadata.image);
            (label === 'INKSPIRE' ? inkspireURIs : badgeURIs).push({ src: image, name: metadata.name });
            if (metadata.name.includes("Let's Ape")) badge2 = true;
            if (metadata.name.includes("$HOES Anthem")) badge3 = true;
            if (!badge1 && label === 'A') badge1 = true;
          }
        } catch (e) {} finally {
          processed++;
          updateProgressBar(processed, tokenIds.length);
        }
      }
    }

    async function checkOGBadgeLoop() {
      for (let id = 0; id < 100; id++) {
        try {
          const balance = await contractOGInstance.methods.balanceOf(userAddress, id).call();
          if (balance > 0) return true;
        } catch (e) {}
      }
      return false;
    }

    await scanContract(contractAInstance, range(1, 69), 'A');
    await scanContract(contractBInstance, range(1, 420), 'B');
    await scanContract(contractBInstance, range(2800, 4000), 'B');
    await scanContract(inkspireInstance, range(1, 100), 'INKSPIRE');

    badge5 = inkspireURIs.length > 0;
    const ogBadgeUnlocked = await checkOGBadgeLoop();

    document.getElementById("badgeOneStatus").innerHTML = badge1 ? "âœ… <span class='unlocked'>Royalty Music Pass Unlock</span>" : "ðŸ”’ <span class='locked'>Badge 1 Locked</span>";
    document.getElementById("badgeTwoStatus").innerHTML = badge2 ? "âœ… <span class='unlocked'>Badge 2 Unlocked (\"Let's Ape\")</span>" : "ðŸ”’ <span class='locked'>Badge 2 Locked</span>";
    document.getElementById("badgeThreeStatus").innerHTML = badge3 ? "âœ… <span class='unlocked'>Badge 3 Unlocked (\"$HOES Anthem\")</span>" : "ðŸ”’ <span class='locked'>Badge 3 Locked</span>";
    document.getElementById("badgeFourStatus").innerHTML = ogBadgeUnlocked ? "âœ… <span class='unlocked'>OG Supporter</span>" : "ðŸ”’ <span class='locked'>Badge 4 Locked</span>";
    document.getElementById("badgeFiveStatus").innerHTML = badge5 ? "âœ… <span class='unlocked'>DripHeadz</span>" : "ðŸ”’ <span class='locked'>Dripheadz NFT Not Found</span>";

    if (badge1) {
      const video = document.createElement("video");
      video.src = "royaltypass.MP4";
      video.autoplay = video.loop = video.muted = true;
      video.playsInline = true;
      const slot = document.createElement("div");
      slot.className = "badge-slot";
      slot.appendChild(video);
      badgeGrid.appendChild(slot);
    }

    badgeURIs.forEach(item => {
      const slot = document.createElement("div");
      slot.className = "badge-slot";
      const img = document.createElement("img");
      img.src = item.src;
      img.alt = img.title = item.name;
      slot.appendChild(img);
      badgeGrid.appendChild(slot);
    });

    if (ogBadgeUnlocked) {
      const slot = document.createElement("div");
      slot.className = "badge-slot";
      const img = document.createElement("img");
      img.src = "apestrong.jpg";
      img.alt = "OG Holder Badge";
      slot.appendChild(img);
      badgeGrid.appendChild(slot);
    }

    const totalSlots = 6;
    const currentSlots = badgeGrid.querySelectorAll(".badge-slot").length;
    for (let i = currentSlots; i < totalSlots; i++) {
      const slot = document.createElement("div");
      slot.className = "badge-slot";
      slot.innerText = "Empty Record Slot";
      badgeGrid.appendChild(slot);
    }

    inkspireURIs.forEach(item => {
      const slot = document.createElement("div");
      slot.className = "badge-slot";
      const img = document.createElement("img");
      img.src = item.src;
      img.alt = img.title = item.name;
      slot.appendChild(img);
      inkspireGrid.appendChild(slot);
    });

    clearInterval(intervalId);
    document.getElementById("loadingIndicator").style.display = "none";
  }
</script>

